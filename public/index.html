<!DOCTYPE html>
<html lang="pl" dir="ltr">
<head>
    <meta charset="utf-8">
    <title>ECHO LIVE</title>
    <meta name="theme-color" content="#000">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="images/favicon_black.png">
</head>
<body>

<div id="videos-container"></div>

<script src="RTCMultiConnection.js"></script>
<script src="/webrtc-adapter.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
    let roomid = 'echo-live-webrtc';

    let connection = new RTCMultiConnection();
    connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';
    connection.socketMessageEvent = 'echo-live-webrtc';
    connection.session = {
        audio: true,
        video: false,
        oneway: true
    };
    connection.codecs = {
        video: 'H264',
        audio: 'opus'
    };
    connection.bandwidth = {
        video: 1024,
        audio: 320
    };
    let width = 1920;
    let height = 1080;

    let audioConfig = {
        mandatory: {},
        optional: [{
            echoCancellation: false
        }]
    };

    connection.mediaConstraints = {
        audio: audioConfig,
        video: {
            mandatory: {
                minWidth: width,
                maxWidth: width,
                minHeight: height,
                maxHeight: height
            },
            optional: []
        }
    };

    if (DetectRTC.browser.name === 'Firefox') {
        connection.mediaConstraints = {
            audio: audioConfig,
            video: {
                width: width,
                height: height
            }
        };
    }
    connection.sdpConstraints.mandatory = {
        OfferToReceiveAudio: false,
        OfferToReceiveVideo: false
    };
    connection.videosContainer = document.getElementById('videos-container');
    connection.onstream = function (event) {
        let existing = document.getElementById(event.streamid);
        if (existing && existing.parentNode) {
            existing.parentNode.removeChild(existing);
        }

        event.mediaElement.removeAttribute('src');
        event.mediaElement.removeAttribute('srcObject');
        event.mediaElement.muted = true;
        event.mediaElement.volume = 0;

        let video = document.createElement('video');

        try {
            video.setAttributeNode(document.createAttribute('autoplay'));
            video.setAttributeNode(document.createAttribute('playsinline'));
            video.setAttributeNode(document.createAttribute('controls'));
        } catch (e) {
            video.setAttribute('autoplay', true);
            video.setAttribute('playsinline', true);
            video.setAttribute('controls', true);
        }

        if (event.type === 'local') {
            video.volume = 0;
            try {
                video.setAttributeNode(document.createAttribute('muted'));
            } catch (e) {
                video.setAttribute('muted', true);
            }
        }
        video.srcObject = event.stream;

        connection.videosContainer.appendChild(video);

        setTimeout(function () {
            video.play();
        }, 5000);
    };

    connection.onstreamended = function (event) {
        let mediaElement = document.getElementById(event.streamid);
        if (mediaElement) {
            mediaElement.parentNode.removeChild(mediaElement);

            if (event.userid === connection.sessionid && !connection.isInitiator) {
                alert('Broadcast is ended. We will reload this page to clear the cache.');
                location.reload();
            }
        }
    };

    connection.onMediaError = function (e) {
        if (e.message === 'Concurrent mic process limit.') {
            if (DetectRTC.audioInputDevices.length <= 1) {
                alert('Please select external microphone. Check github issue number 483.');
                return;
            }

            let secondaryMic = DetectRTC.audioInputDevices[1].deviceId;
            connection.mediaConstraints.audio = {
                deviceId: secondaryMic
            };

            connection.join(connection.sessionid);
        }
    };

    if (roomid && roomid.length) {
        (function reCheckRoomPresence() {
            connection.checkPresence(roomid, function (isRoomExist) {
                if (isRoomExist) {
                    connection.join(roomid);
                    return;
                }

                setTimeout(reCheckRoomPresence, 5000);
            });
        })();
    }
    //setTimeout(reCheckRoomPresence, 5000);

    // detect 2G
    if (navigator.connection &&
        navigator.connection.type === 'cellular' &&
        navigator.connection.downlinkMax <= 0.115) {
        alert('2G is not supported. Please use a better internet service.');
    }
</script>

</body>
</html>
